# C++

## 1、一个C++源文件从文本到可执行文件经历的过程？

1).预处理，产生.ii文件

2).编译，产生汇编文件(.s文件)

3).汇编，产生目标文件(.o或.obj文件)

4).链接,产生可执行文件(.out或.exe文件)

链接分为两种：

- 静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中
- 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间

二者的优缺点：

- 静态链接 浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容
- 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要进行链接，性能会有一定的损失。

## **2、\#include 的顺序以及尖叫括号和双引号的区别?**

\#include ""

**用户自定义**的文件用双引号括起来，编译器首先会在用户目录下查找，然后在到C++安装目录（比如VC中可以指定和修改库文件查找路径，Unix和Linux中可以通过环境变量来设定）中查找，最后在系统文件中查找。 

\#include <>

**系统自带**的头文件用尖括号括起来，这样编译器会在系统文件目录下查找。 

## **3、C和C++的区别？**

- C是面向过程的语言，而C++是面向对象的语言。所以C++支持继承和多态。C++拥有非常强大的STL模版库。
- C++有非常强大的设计模式，比如单例，工厂，观察者模式等等，这些在C语言当中都是不支持的。
- C和C++一个典型的区别就在动态内存管理上了，C语言通过malloc和free来进行堆内存的分配和释放，而C++是通过new和delete来管理堆内存的。
- 另外强制类型转换上也不一样，C的强制类型转换使用()小括号里面加类型进行类型强转的，而C++有四种自己的类型强转方式，分别是const_cast，static_cast，reinterpret_cast和dynamic_cast。
- C++还支持带有默认值的函数，函数的重载，inline内联函数，这些C语言都不支持，当然还有const这个关键字，C和C++也是有区别的。
- C++不仅支持指针，还支持更安全的引用，不过在汇编代码上，指针和引用的操作是一样的。
- 在C++中，struct关键字不仅可以用来定义结构体，它也可以用来定义类。

## **4、有了进程为什么还要线程？**

线程进程的区别体现在4个方面：

第一：因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。

第二：体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。

第三：体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。

第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。

进程与线程的选择取决以下几点：1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。

## **5、C++11有哪些新特性？**

- 提高运行效率的语言特性：右值引用、泛化常量表达式
- 原有语法的使用性增强：初始化列表、统一的初始化语法、类型推导、范围for循环、Lambda表达式、final和override、构造函数委托
- 语言能力的提升：空指针nullptr、default和delete、长整数、静态assert
- C++标准库的更新：智能指针、正则表达式、哈希表等

## **6、指针和引用的区别？**

- 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）
- 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间（是否占内存）
- 指针可以为空，但是引用必须绑定对象（是否可为空）
- 指针可以有多级，但是引用只能一级（是否能为多级）

## **7、堆和栈的区别？**

- 申请方式：栈是系统自动分配，堆是程序员主动申请
- 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上
- 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的
- 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片
- 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制

## **8、new 和 delete 是如何实现的，new 与 malloc 的异同处？**

在使用的时候 new,delete 搭配使用，malloc 和 free 搭配使用。

- 属性：malloc/free 是库函数，需要头文件的支持；new/delete 是关键字，需要编译器的支持
- 参数：new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小
- 返回值：new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，符合类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针
- 分配失败：new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针
- 重载：new/delete 支持重载，malloc/free 不能进行重载
- 自定义类型实现：new 首先调用 operator new 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete 释放空间（底层通过 free 实现）。malloc/free 无法进行自定义类型的对象的构造和析构
- 内存区域：new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）

## **9、Struct 和 class 的区别？**

struct 和 class 都可以自定义数据类型，也支持继承操作

- struct 中默认的访问级别是 public，默认的继承级别也是 public

- class 中默认的访问级别是 private，默认的继承级别也是 private
- 当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于默认的继承级别取决于class或struct本身， class(private 继承) ，struct(public 继承)
- class 可以使用模板，struct 不能

## **10、define 和 const 的区别（编译阶段、安全性、内存占用等）？**

- 编译阶段：define 是在编译预处理阶段起作用，const 是在编译阶段和程序运行阶段起作用
- 安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的只读变量是有类型的，是要进行判断的，可以避免一些低级的错误
- 内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const 定义的只读变量在程序运行过程中只有一份
- 调试：define 定义的不能调试，因为在预编译阶段就已经进行替换了；const 定义的可以进行调试

const的优点：

- 有数据类型，在定义时可进行安全性检查
- 可调式
- 占用较少的空间

## **11、在C++中const和static的用法（定义、用途）？**

const：

- const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率
- const 修饰函数参数，使得传递过来的函数参数的值不能改变
- const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外，函数参数也除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量

static 定义静态变量，静态函数：

- static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间
- static 作用于全局变量和函数，改变了全局变量的作用域，使得全局变量只能在定义它的文件中使用，在源文件中不具有全局可见性
- static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数

## **12、const 和 static 在类中使用的注意事项（定义、初始化和使用）？**

**static 静态成员变量：**

1. 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和 private/public/protected 访问规则。
2. 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。
3. 静态成员变量可以作为成员函数的参数可选参数，而普通成员变量不可以
4. 静态数据成员的类型可以是所属类的类型，而普通数据成员不可以，普通数据成员只可能声明成类的指针或引用

**static静态成员函数：**

1. 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数
2. 静态成员函数不能声明成虚函数（virtual）、const、volatile

**const成员变量：**

1. const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化
2. const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的，所以不能在类的声明中初始化 const 成员变量，因为类的对象还没有创建，编译器不知道他的值

**const成员函数：**

1. 不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量
2. 不能调用非常量成员函数，以防修改成员变量的值

**const static：**

如果要想成员变量在整个类中都是恒定的常量，应该用类的枚举常量或者 static const.
在类中进行声明，在类外进行初始化（类似于类的静态常量）

## **13、STL源码中hash表的实现？**

hashtable 是采用开链法来完成的，（vector + list）

- 底层键值序列采用 vector 实现，vector 的大小取的是质数，且相邻质数的大小约为 2 倍关系，当创建 hashtable 时，会自动选取一个接近所创建大小的质数作为当前 hashtable 的大小；
- 对应键的值序列采用单向 list 实现；
- 当 hashtable 的键 vector 的大小重新分配的时候，原键的值 list 也会重新分配，因为 vector 重建了相当于键增加了，那么原来的值对应的键可能就不同于原来分配的键，这样就需要重新确定值的键。

## **14、STL 中 unordered_map 和 map 的区别？**

- 底层实现不同：
  unordered_map 底层实现是一个哈希表，元素无序
  map 底层实现是红黑树，其内部所有的元素都是有序的，因此对 map 的所有操作，其实都是对红黑树的操作
- 优缺点：
  unordered_map：查找效率高；但是建立哈希表比较耗费时间
  map：内部元素有序，查找和删除操作都是 logn 的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间
- 适用情况：
  对于要求内部元素有序的使用 map，对于要求查找效率的用 unordered_map

## **15、STL 中 vector 的实现**

vector 是一个动态数组，底层实现是一段连续的线性内存空间。
扩容的本质：当 vector 实际所占用的内存空间和容量相等时，如果再往其中添加元素需要进行扩容。其步骤如下：

- 首先，申请一块更大的存储空间，一般是增加当前容量的 50% 或者 100%，和编译器有关；
- 然后，将旧内存空间的内容，按照原来的顺序放到新的空间中
- 最后，将旧内存空间的内容释放掉，本质上其存储空间不会释放，只是删除了里面的内容。

从 vector 扩容的原理也可以看出：vector 容器释放后，与其相关的指针、引用以及迭代器会失效的原因。

## **16、vector 使用的注意点及其原因，频繁对 vector 调用 push_back() 对性能的影响和原因？**

主要是在插入元素方面：插入元素需要考虑元素的移动问题和是否需要扩容的问题
频繁的调用 push_back() 也是扩容的问题对性能的影响

## **17、C++ 中的重载和重写(覆盖)的区别？**

- 对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间，子类和父类之间
- 重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰
  - 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！
  - 重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。
- virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有

## **18、C++ 内存管理**

C++ 内存分区：栈、堆、自由存储区、全局/静态存储区、常量区

- 栈：存放函数的局部变量，由编译器自动分配和释放
- 堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收
- 自由存储区：和堆十分相似，存放由 new 分配的内存块，由 delete 释放内存
- 全局区/静态区：存放全局变量和静态变量
- 常量存储区：存放的是常量，不允许修改

堆和自由存储区的区别：

- 自由存储是 C++ 中通过 new 与 delete 动态分配和释放对象的抽象概念，而堆是 C 语言和操作系统的术语，是操作系统维护的一块动态分配内存
- new 所申请的内存区域在 C++ 中成为自由存储区。藉由堆实现的自由存储，可以说 new 所申请的内存区域在堆上
- 堆和自由存储区有区别，并非等价。使用 new 来分配内存，程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。

## **19、指针和数组的对比**

1. 字符数组的内容可以改变，字符指针的内容不可以改变
2. 字符数组之间不能赋值，不能直接用比较运算符直接比较，若进行赋值调用 strcpy() 函数，若进行比较调用 strcmp() 函数；
3. 运算符 sizeof 可以计算出字符数组的容量，但是计算字符指针时，得到的是指针变量所占用的空间，而不是指针所指向空间的大小。

## **20、在一个函数中如何返回一个变量的指针？**

对于普通变量而言，是存储在栈内存中，当函数调用完毕后，栈内存的空间会被释放，如果返回局部变量的指针，回到主调函数后，该指针是悬挂指针指向垃圾内存，如何来处理这种情况呢？

可以返回存储在堆内存或者全局区的变量的指针：

- 返回静态类型对象的指针，会导致占用大量的内存空间
- 返回存放在堆上的对象的指针，该对象所在的内存空间由用户控制什么时候释放，那如何知道什么时候释放合适呢？可以用只智能指针来处理，智能指针内部有计数器，当计数器为 0 时，会自动释放该内存。

## **21、出现野指针的情形？**

1. 指针定义的时候未初始化
2. 指针指向动态分配的内存空间在释放（delete 或 free）后，未置为 NULL，让人误以为是合法指针
3. 指针操作超过了变量的作用范围。例如：在函数中将一个局部变量的地址作为函数的返回值，这里编译器会给出警告，因为离开该函数后，局部变量的空间就会释放掉，返回的地址（指针）相当于是野指针。

## **22、深拷贝和浅拷贝带来的问题：**

类中默认的拷贝构造函数和赋值构造函数都是浅拷贝，当类的成员变量中出现指针变量时，最好使用深拷贝，避免内存空间多次释放的问题出现。

## **23、new、delete、malloc、free关系**

delete会调用对象的析构函数,和new对应。free只会释放内存，new调用构造函数。malloc与free是C++/C语言的**标准库函数**，new/delete是**C++的运算符**。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

delete与 delete []区别：

- delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套

## 24、子类析构时要调用父类的析构函数吗？

析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。

## 25、什么是“引用”？申明和使用“引用”要注意哪些问题？

引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。声明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。

## 26、将“引用”作为函数参数有哪些特点？

- 传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
- 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
- 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

## 27、在什么时候需要使用“常引用”？　

如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名；

## 28、将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?

格式：类型标识符 &函数名（形参列表及类型说明）{ //函数体 }

好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! 

注意事项：

- 不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
- 不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
- 可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
- 流操作符重载返回值申明为“引用”的作用：
  - 流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 
  - 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

## 29、有哪几种情况只能用intialization list 而不能用assignment?

当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。

## 30、C++是不是类型安全的？

不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

## 31、main 函数执行以前，还会执行什么代码？

全局对象的构造函数会在main 函数之前执行。

## 32、描述内存分配方式以及它们的区别?

- 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
-  在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
-  从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。

## 33、基类的析构函数不是虚函数，会带来什么问题？

C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

## 34、全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？

生命周期不同：

全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 

操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

## 35、**宏定义和内联函数的区别**

- 宏定义不是函数，预处理器用赋值宏代码的方式代替函数的调用，省去了函数压栈退栈过程。

  内联函数本质是一个函数，不能包含复杂的控制，如果内敛函数体过大，编译器会自动把这个内联函数变成普通函数

  内联函数是在编译的时候进行代码插入，编译器在调用内联函数的地方直接把内联函数内容展开。省区函数的调用开销。

- 宏定义没有类型检查。内联函数在编译的时候进行类型检查
- 宏定义和内敛都是进行diamagnetic展开。不同点，宏定义在预编译的时候把所有宏名字替换，内联函数在编译阶段把所有调用内敛函数的地方进行内联函数插入，省区函数压栈清栈

# 计算机网络

## 1、**三次握手？**

**TCP连接的建立（三次握手）：**

**最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。**

1. TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
2. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4. TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
5. 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

*为什么TCP客户端最后还要发送一次确认呢？*

一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

## 2、**四次挥手？**

**TCP连接的释放（四次挥手）：**

**数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。**

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

==*为什么客户端最后还要等待2MSL？*==

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

*==为什么建立连接是三次握手，关闭连接确是四次挥手呢？==*

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。